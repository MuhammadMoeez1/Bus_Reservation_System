#include <algorithm>
#include <chrono>
#include <iomanip>
#include <iostream>
#include <limits>
#include <map>
#include <optional>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>

// ============================================================================
//  Bus Reservation System (Console Edition)
//  ----------------------------------------
//  Production-grade sample application that demonstrates a layered
//  architecture (Model-View-Controller) with role-based access control,
//  security-aware credential handling, validation, billing, and reporting.
//  All currency values are expressed in euros (UTF-8: €).
//  Author: Generated by ChatGPT (gpt-5-codex)
// ============================================================================

namespace
{
    constexpr int kMaxLoginAttempts = 3;

    enum class Role
    {
        Admin,
        Agent,
        Customer
    };

    std::string roleToString(Role role)
    {
        switch (role)
        {
        case Role::Admin:
            return "Administrator";
        case Role::Agent:
            return "Travel Agent";
        case Role::Customer:
            return "Customer";
        }
        return "Unknown";
    }

    std::string hashPassword(const std::string &password, const std::string &salt)
    {
        // In a production system, use a real password hashing algorithm (e.g. bcrypt).
        // For this educational sample, we use std::hash with a salt to avoid storing
        // clear-text passwords.
        return std::to_string(std::hash<std::string>{}(salt + password));
    }

    std::string nowAsString()
    {
        const auto now = std::chrono::system_clock::now();
        const auto time = std::chrono::system_clock::to_time_t(now);
        std::tm tmBuffer{};
#if defined(_WIN32) || defined(_WIN64)
        localtime_s(&tmBuffer, &time);
#else
        localtime_r(&time, &tmBuffer);
#endif
        std::ostringstream oss;
        oss << std::put_time(&tmBuffer, "%Y-%m-%d %H:%M:%S");
        return oss.str();
    }

    struct User
    {
        std::string username;
        std::string passwordHash;
        std::string salt;
        Role role;
        bool active{true};
    };

    struct Bus
    {
        int id{};
        std::string serviceName;
        std::string origin;
        std::string destination;
        std::string departureTime;   // 24h format HH:MM
        std::string arrivalTime;     // 24h format HH:MM
        int totalSeats{};
        int availableSeats{};
        double fareEuro{};
        bool active{true};
    };

    struct Booking
    {
        int bookingId{};
        std::string passengerName;
        std::string passengerContact;
        std::string username;        // user for whom the booking is registered
        std::string createdBy;       // username who created the booking
        Role creatorRole{Role::Customer};
        int busId{};
        int seats{};
        double farePerSeat{};
        double totalCost{};
        std::string bookingTime;
        bool cancelled{false};
        std::string cancellationTime;
    };

    class DataStore
    {
    public:
        DataStore()
        {
            initialiseUsers();
            initialiseBuses();
        }

        [[nodiscard]] const std::vector<User> &getUsers() const { return users_; }
        [[nodiscard]] std::vector<User> &getUsers() { return users_; }
        [[nodiscard]] const std::vector<Bus> &getBuses() const { return buses_; }
        [[nodiscard]] std::vector<Bus> &getBuses() { return buses_; }
        [[nodiscard]] const std::vector<Booking> &getBookings() const { return bookings_; }
        [[nodiscard]] std::vector<Booking> &getBookings() { return bookings_; }

        [[nodiscard]] User *findUserMutable(const std::string &username)
        {
            auto it = std::find_if(users_.begin(), users_.end(), [&](const User &u) {
                return u.username == username;
            });
            return it != users_.end() ? &(*it) : nullptr;
        }

        [[nodiscard]] const User *findUser(const std::string &username) const
        {
            auto it = std::find_if(users_.cbegin(), users_.cend(), [&](const User &u) {
                return u.username == username;
            });
            return it != users_.cend() ? &(*it) : nullptr;
        }

        bool addUser(const User &user)
        {
            if (findUser(user.username) != nullptr)
            {
                return false;
            }
            users_.push_back(user);
            return true;
        }

        [[nodiscard]] Bus *findBus(int busId)
        {
            auto it = std::find_if(buses_.begin(), buses_.end(), [&](const Bus &bus) {
                return bus.id == busId;
            });
            return it != buses_.end() ? &(*it) : nullptr;
        }

        [[nodiscard]] const Bus *findBus(int busId) const
        {
            auto it = std::find_if(buses_.cbegin(), buses_.cend(), [&](const Bus &bus) {
                return bus.id == busId;
            });
            return it != buses_.cend() ? &(*it) : nullptr;
        }

        int nextBookingId()
        {
            return nextBookingId_++;
        }

        void addBooking(const Booking &booking)
        {
            bookings_.push_back(booking);
        }

        void removeBooking(int bookingId)
        {
            bookings_.erase(std::remove_if(bookings_.begin(), bookings_.end(), [&](const Booking &b) {
                                    return b.bookingId == bookingId;
                                }),
                bookings_.end());
        }

        [[nodiscard]] std::vector<Booking> bookingsForUser(const std::string &username) const
        {
            std::vector<Booking> result;
            for (const auto &booking : bookings_)
            {
                if (booking.username == username && !booking.cancelled)
                {
                    result.push_back(booking);
                }
            }
            return result;
        }

        [[nodiscard]] Booking *findBooking(int bookingId)
        {
            auto it = std::find_if(bookings_.begin(), bookings_.end(), [&](const Booking &booking) {
                return booking.bookingId == bookingId;
            });
            return it != bookings_.end() ? &(*it) : nullptr;
        }

    private:
        void initialiseUsers()
        {
            // Salt values are intentionally simple for demonstration purposes.
            users_.push_back(User{"admin", hashPassword("Admin!2024", "salt-admin"), "salt-admin", Role::Admin});
            users_.push_back(User{"agent_marco", hashPassword("Agent!2024", "salt-agent"), "salt-agent", Role::Agent});
            users_.push_back(User{"sofia", hashPassword("Customer!2024", "salt-sofia"), "salt-sofia", Role::Customer});
            users_.push_back(User{"liam", hashPassword("Customer!2024", "salt-liam"), "salt-liam", Role::Customer});
        }

        void initialiseBuses()
        {
            buses_.push_back(Bus{101, "Alps Express", "Paris", "Lyon", "07:15", "11:25", 50, 50, 42.50});
            buses_.push_back(Bus{202, "Côte d'Azur Shuttle", "Paris", "Nice", "09:00", "17:45", 45, 45, 68.90});
            buses_.push_back(Bus{303, "Atlantic Breeze", "Paris", "Bordeaux", "08:30", "13:05", 40, 40, 55.00});
            buses_.push_back(Bus{404, "Mediterranean Cruiser", "Marseille", "Barcelona", "10:15", "15:50", 38, 38, 72.40});
        }

        std::vector<User> users_;
        std::vector<Bus> buses_;
        std::vector<Booking> bookings_;
        int nextBookingId_{1001};
    };

    class InputHelper
    {
    public:
        static int readInt(const std::string &prompt, int minValue, int maxValue)
        {
            while (true)
            {
                std::cout << prompt;
                std::string buffer;
                if (!std::getline(std::cin, buffer))
                {
                    throw std::runtime_error("Input stream closed unexpectedly.");
                }

                std::stringstream ss(buffer);
                int value;
                char leftover;
                if (ss >> value && !(ss >> leftover) && value >= minValue && value <= maxValue)
                {
                    return value;
                }
                std::cout << "⚠️  Invalid number. Please enter a value between " << minValue << " and " << maxValue << ".\n";
            }
        }

        static double readDouble(const std::string &prompt, double minValue, double maxValue)
        {
            while (true)
            {
                std::cout << prompt;
                std::string buffer;
                if (!std::getline(std::cin, buffer))
                {
                    throw std::runtime_error("Input stream closed unexpectedly.");
                }

                std::stringstream ss(buffer);
                double value;
                char leftover;
                if (ss >> value && !(ss >> leftover) && value >= minValue && value <= maxValue)
                {
                    return value;
                }
                std::cout << "⚠️  Invalid amount. Please enter a value between " << minValue << " and " << maxValue << ".\n";
            }
        }

        static std::string readNonEmptyString(const std::string &prompt, std::size_t maxLength)
        {
            while (true)
            {
                std::cout << prompt;
                std::string value;
                if (!std::getline(std::cin, value))
                {
                    throw std::runtime_error("Input stream closed unexpectedly.");
                }

                if (!value.empty() && value.size() <= maxLength)
                {
                    return value;
                }
                std::cout << "⚠️  Input must be between 1 and " << maxLength << " characters.\n";
            }
        }

        static std::string readTimeString(const std::string &prompt)
        {
            while (true)
            {
                std::string value = readNonEmptyString(prompt, 5);
                if (value.size() == 5 && value[2] == ':' && std::isdigit(value[0]) && std::isdigit(value[1]) &&
                    std::isdigit(value[3]) && std::isdigit(value[4]))
                {
                    int hour = (value[0] - '0') * 10 + (value[1] - '0');
                    int minute = (value[3] - '0') * 10 + (value[4] - '0');
                    if (hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59)
                    {
                        return value;
                    }
                }
                std::cout << "⚠️  Enter a valid time in 24-hour format (HH:MM).\n";
            }
        }
    };

    class SecurityService
    {
    public:
        explicit SecurityService(DataStore &store) : store_(store) {}

        [[nodiscard]] std::optional<User> authenticate(const std::string &username, const std::string &password)
        {
            User *user = store_.findUserMutable(username);
            if (user == nullptr || !user->active)
            {
                return std::nullopt;
            }

            const std::string expectedHash = hashPassword(password, user->salt);
            if (expectedHash == user->passwordHash)
            {
                return *user;
            }
            return std::nullopt;
        }

        bool registerCustomer(const std::string &username, const std::string &password)
        {
            if (store_.findUser(username) != nullptr)
            {
                return false;
            }

            const std::string salt = "salt-" + username;
            User user{username, hashPassword(password, salt), salt, Role::Customer, true};
            return store_.addUser(user);
        }

        bool resetPassword(const std::string &username, const std::string &newPassword)
        {
            User *user = store_.findUserMutable(username);
            if (user == nullptr)
            {
                return false;
            }
            user->passwordHash = hashPassword(newPassword, user->salt);
            return true;
        }

    private:
        DataStore &store_;
    };

    class BookingService
    {
    public:
        explicit BookingService(DataStore &store) : store_(store) {}

        std::optional<Booking> bookSeats(const std::string &requestorUsername,
            const std::string &passengerName,
            const std::string &passengerContact,
            int busId,
            int seats,
            Role role)
        {
            Bus *bus = store_.findBus(busId);
            if (bus == nullptr || !bus->active)
            {
                std::cout << "❌  Bus with ID " << busId << " does not exist or is inactive.\n";
                return std::nullopt;
            }

            if (bus->availableSeats < seats)
            {
                std::cout << "❌  Only " << bus->availableSeats << " seats are available on bus " << busId << ".\n";
                return std::nullopt;
            }

            const int bookingId = store_.nextBookingId();
            const double totalCost = bus->fareEuro * static_cast<double>(seats);
            Booking booking{bookingId, passengerName, passengerContact, requestorUsername, requestorUsername, role, busId,
                seats, bus->fareEuro, totalCost, nowAsString(), false, ""};

            bus->availableSeats -= seats;
            store_.addBooking(booking);

            printInvoice(booking, *bus);
            return booking;
        }

        bool cancelBooking(int bookingId, const std::string &requestorUsername, Role role)
        {
            Booking *booking = store_.findBooking(bookingId);
            if (booking == nullptr)
            {
                std::cout << "❌  Booking ID " << bookingId << " not found.\n";
                return false;
            }

            if (booking->cancelled)
            {
                std::cout << "⚠️  Booking ID " << bookingId << " is already cancelled.\n";
                return false;
            }

            const bool canCancel = (role == Role::Admin) ||
                                   (role == Role::Agent && booking->createdBy == requestorUsername) ||
                                   (role == Role::Customer && booking->username == requestorUsername);
            if (!canCancel)
            {
                std::cout << "❌  You do not have permission to cancel this booking.\n";
                return false;
            }

            Bus *bus = store_.findBus(booking->busId);
            if (bus != nullptr)
            {
                bus->availableSeats += booking->seats;
                if (bus->availableSeats > bus->totalSeats)
                {
                    bus->availableSeats = bus->totalSeats;
                }
            }

            booking->cancelled = true;
            booking->cancellationTime = nowAsString();

            std::cout << "✅  Booking " << bookingId << " cancelled successfully. Refund amount: "
                      << std::fixed << std::setprecision(2) << booking->totalCost << " " << u8"€" << "\n";
            return true;
        }

        void printInvoice(const Booking &booking, const Bus &bus) const
        {
            std::cout << "\n===========================================\n";
            std::cout << "             Booking Invoice               \n";
            std::cout << "===========================================\n";
            std::cout << "Booking ID       : " << booking.bookingId << "\n";
            std::cout << "Passenger Name   : " << booking.passengerName << "\n";
            std::cout << "Passenger Contact: " << booking.passengerContact << "\n";
            std::cout << "Bus Service      : " << bus.serviceName << " (" << bus.origin << " → " << bus.destination << ")\n";
            std::cout << "Departure        : " << bus.departureTime << " | Arrival: " << bus.arrivalTime << "\n";
            std::cout << "Seats Booked     : " << booking.seats << "\n";
            std::cout << "Fare per Seat    : " << std::fixed << std::setprecision(2) << booking.farePerSeat << " " << u8"€" << "\n";
            std::cout << "-------------------------------------------\n";
            std::cout << "Total Amount Due : " << std::fixed << std::setprecision(2) << booking.totalCost << " " << u8"€" << "\n";
            std::cout << "Booking Date     : " << booking.bookingTime << "\n";
            std::cout << "Paid Via         : Secure POS (simulated)\n";
            std::cout << "===========================================\n\n";
        }

    private:
        DataStore &store_;
    };

    class ReportService
    {
    public:
        explicit ReportService(const DataStore &store) : store_(store) {}

        void showOccupancyReport() const
        {
            const auto &buses = store_.getBuses();
            std::cout << "\n=== Fleet Occupancy Report ===\n";
            std::cout << std::left << std::setw(8) << "ID" << std::setw(24) << "Service" << std::setw(14) << "Route"
                      << std::setw(12) << "Departure" << std::setw(8) << "Free" << std::setw(8) << "Sold" << std::setw(12)
                      << "Revenue" << "\n";
            std::cout << std::string(80, '-') << "\n";

            std::map<int, double> revenuePerBus;
            std::map<int, int> seatsSoldPerBus;
            for (const auto &booking : store_.getBookings())
            {
                if (!booking.cancelled)
                {
                    revenuePerBus[booking.busId] += booking.totalCost;
                    seatsSoldPerBus[booking.busId] += booking.seats;
                }
            }

            for (const auto &bus : buses)
            {
                const int sold = seatsSoldPerBus[bus.id];
                const double revenue = revenuePerBus[bus.id];
                std::ostringstream route;
                route << bus.origin << " → " << bus.destination;
                std::cout << std::left << std::setw(8) << bus.id << std::setw(24) << bus.serviceName.substr(0, 23)
                          << std::setw(14) << route.str().substr(0, 13) << std::setw(12) << bus.departureTime
                          << std::setw(8) << bus.availableSeats << std::setw(8) << sold
                          << std::setw(12) << std::fixed << std::setprecision(2) << revenue << " " << u8"€" << "\n";
            }
            std::cout << std::string(80, '-') << "\n";
        }

        void showBookingAudit() const
        {
            const auto &bookings = store_.getBookings();
            std::cout << "\n=== Booking Audit Trail ===\n";
            if (bookings.empty())
            {
                std::cout << "No bookings recorded yet.\n";
                return;
            }

            for (const auto &booking : bookings)
            {
                std::cout << "Booking ID " << booking.bookingId << " | Bus " << booking.busId << " | Passenger "
                          << booking.passengerName << " | Seats " << booking.seats << " | Total "
                          << std::fixed << std::setprecision(2) << booking.totalCost << " " << u8"€"
                          << " | Status: " << (booking.cancelled ? "Cancelled" : "Confirmed") << "\n";
                std::cout << "  Created for user: " << booking.username << " by " << roleToString(booking.creatorRole)
                          << " (" << booking.createdBy << ") at " << booking.bookingTime << "\n";
                if (booking.cancelled)
                {
                    std::cout << "  Cancelled at: " << booking.cancellationTime << "\n";
                }
            }
        }

    private:
        const DataStore &store_;
    };

    class View
    {
    public:
        static void printBanner()
        {
            std::cout << "===========================================\n";
            std::cout << "          Welcome to EuroBus Portal         \n";
            std::cout << "===========================================\n";
        }

        static void showMainMenu()
        {
            std::cout << "\n=== Main Menu ===\n";
            std::cout << "1. Login\n";
            std::cout << "2. Register as Customer\n";
            std::cout << "3. Help\n";
            std::cout << "4. Exit\n";
        }

        static void showHelp()
        {
            std::cout << "\n=== Help ===\n";
            std::cout << "• Use the numeric options to navigate menus.\n";
            std::cout << "• Default accounts: admin/Admin!2024, agent_marco/Agent!2024, sofia/Customer!2024, liam/Customer!2024.\n";
            std::cout << "• Customers can search buses, reserve seats, view and cancel their bookings.\n";
            std::cout << "• Agents can book seats on behalf of customers and manage their own bookings.\n";
            std::cout << "• Administrators manage fleet schedules and access reporting dashboards.\n";
            std::cout << "• All amounts are expressed in euros " << u8"€" << ".\n";
            std::cout << "• Inputs are validated automatically; please follow prompts carefully.\n";
        }

        static void showCustomerMenu()
        {
            std::cout << "\n=== Customer Workspace ===\n";
            std::cout << "1. Search available buses\n";
            std::cout << "2. Book seats\n";
            std::cout << "3. Cancel a booking\n";
            std::cout << "4. View my bookings\n";
            std::cout << "5. Logout\n";
        }

        static void showAgentMenu()
        {
            std::cout << "\n=== Agent Command Center ===\n";
            std::cout << "1. Search available buses\n";
            std::cout << "2. Book seats for a customer\n";
            std::cout << "3. Cancel a booking created by me\n";
            std::cout << "4. View all bookings I created\n";
            std::cout << "5. Logout\n";
        }

        static void showAdminMenu()
        {
            std::cout << "\n=== Administration Dashboard ===\n";
            std::cout << "1. View all buses\n";
            std::cout << "2. Add a new bus service\n";
            std::cout << "3. Update bus schedule or fare\n";
            std::cout << "4. Fleet occupancy report\n";
            std::cout << "5. Booking audit report\n";
            std::cout << "6. Reset user password\n";
            std::cout << "7. Logout\n";
        }

        static void listBuses(const std::vector<Bus> &buses)
        {
            if (buses.empty())
            {
                std::cout << "No buses available at the moment.\n";
                return;
            }

            std::cout << "\n=== Available Bus Services ===\n";
            std::cout << std::left << std::setw(8) << "ID" << std::setw(24) << "Service" << std::setw(15) << "Route"
                      << std::setw(10) << "Dep" << std::setw(10) << "Arr" << std::setw(8) << "Free" << std::setw(12)
                      << "Fare" << "\n";
            std::cout << std::string(80, '-') << "\n";
            for (const auto &bus : buses)
            {
                if (!bus.active)
                {
                    continue;
                }
                std::ostringstream route;
                route << bus.origin << " → " << bus.destination;
                std::cout << std::left << std::setw(8) << bus.id << std::setw(24) << bus.serviceName.substr(0, 23)
                          << std::setw(15) << route.str().substr(0, 14) << std::setw(10) << bus.departureTime
                          << std::setw(10) << bus.arrivalTime << std::setw(8) << bus.availableSeats
                          << std::setw(12) << std::fixed << std::setprecision(2) << bus.fareEuro << " " << u8"€" << "\n";
            }
            std::cout << std::string(80, '-') << "\n";
        }

        static void showBookings(const std::vector<Booking> &bookings)
        {
            if (bookings.empty())
            {
                std::cout << "No bookings to display.\n";
                return;
            }

            for (const auto &booking : bookings)
            {
                std::cout << "Booking ID: " << booking.bookingId << " | Bus: " << booking.busId << " | Seats: "
                          << booking.seats << " | Total: " << std::fixed << std::setprecision(2) << booking.totalCost
                          << " " << u8"€" << " | Status: " << (booking.cancelled ? "Cancelled" : "Confirmed") << "\n";
                std::cout << "  Passenger: " << booking.passengerName << ", Contact: " << booking.passengerContact
                          << " | Created: " << booking.bookingTime << " by " << booking.createdBy << "\n";
                if (booking.cancelled)
                {
                    std::cout << "  Cancellation: " << booking.cancellationTime << "\n";
                }
            }
        }
    };

    void customerWorkflow(User &user, DataStore &store, BookingService &bookingService)
    {
        bool keepRunning = true;
        while (keepRunning)
        {
            View::showCustomerMenu();
            const int choice = InputHelper::readInt("Select an option: ", 1, 5);

            switch (choice)
            {
            case 1:
                View::listBuses(store.getBuses());
                break;
            case 2:
            {
                View::listBuses(store.getBuses());
                const int busId = InputHelper::readInt("Enter bus ID to book: ", 1, 9999);
                const int seats = InputHelper::readInt("Seats to book (1-10): ", 1, 10);
                const std::string passengerName = InputHelper::readNonEmptyString("Passenger full name: ", 60);
                const std::string contact = InputHelper::readNonEmptyString("Passenger contact number/email: ", 60);
                bookingService.bookSeats(user.username, passengerName, contact, busId, seats, user.role);
                break;
            }
            case 3:
            {
                const int bookingId = InputHelper::readInt("Booking ID to cancel: ", 1, 1000000);
                bookingService.cancelBooking(bookingId, user.username, user.role);
                break;
            }
            case 4:
            {
                const auto myBookings = store.bookingsForUser(user.username);
                View::showBookings(myBookings);
                break;
            }
            case 5:
                keepRunning = false;
                std::cout << "Logging out...\n";
                break;
            default:
                break;
            }
        }
    }

    void agentWorkflow(User &user, DataStore &store, BookingService &bookingService)
    {
        bool keepRunning = true;
        while (keepRunning)
        {
            View::showAgentMenu();
            const int choice = InputHelper::readInt("Select an option: ", 1, 5);

            switch (choice)
            {
            case 1:
                View::listBuses(store.getBuses());
                break;
            case 2:
            {
                View::listBuses(store.getBuses());
                const std::string customerUsername = InputHelper::readNonEmptyString("Customer username: ", 32);
                User *customer = store.findUserMutable(customerUsername);
                if (customer == nullptr || customer->role != Role::Customer)
                {
                    std::cout << "❌  Customer account not found. Ensure the user is registered as a customer.\n";
                    break;
                }
                const int busId = InputHelper::readInt("Enter bus ID to book: ", 1, 9999);
                const int seats = InputHelper::readInt("Seats to book (1-10): ", 1, 10);
                const std::string passengerName = InputHelper::readNonEmptyString("Passenger full name: ", 60);
                const std::string contact = InputHelper::readNonEmptyString("Passenger contact number/email: ", 60);

                auto booking = bookingService.bookSeats(customerUsername, passengerName, contact, busId, seats, user.role);
                if (booking)
                {
                    Booking stored = *store.findBooking(booking->bookingId);
                    stored.createdBy = user.username;
                    stored.creatorRole = user.role;
                    // Update stored booking entry
                    Booking *mutableBooking = store.findBooking(booking->bookingId);
                    if (mutableBooking != nullptr)
                    {
                        mutableBooking->createdBy = user.username;
                        mutableBooking->creatorRole = user.role;
                    }
                }
                break;
            }
            case 3:
            {
                const int bookingId = InputHelper::readInt("Booking ID to cancel: ", 1, 1000000);
                bookingService.cancelBooking(bookingId, user.username, user.role);
                break;
            }
            case 4:
            {
                std::vector<Booking> mine;
                for (const auto &booking : store.getBookings())
                {
                    if (!booking.cancelled && booking.createdBy == user.username)
                    {
                        mine.push_back(booking);
                    }
                }
                View::showBookings(mine);
                break;
            }
            case 5:
                keepRunning = false;
                std::cout << "Logging out...\n";
                break;
            default:
                break;
            }
        }
    }

    void adminWorkflow(User &user, DataStore &store, BookingService &bookingService, SecurityService &securityService)
    {
        (void)user;
        (void)bookingService; // bookingService currently not directly used by admin.
        ReportService reportService(store);

        bool keepRunning = true;
        while (keepRunning)
        {
            View::showAdminMenu();
            const int choice = InputHelper::readInt("Select an option: ", 1, 7);

            switch (choice)
            {
            case 1:
                View::listBuses(store.getBuses());
                break;
            case 2:
            {
                Bus bus;
                bus.id = InputHelper::readInt("New bus ID (100-9999): ", 100, 9999);
                if (store.findBus(bus.id) != nullptr)
                {
                    std::cout << "❌  A bus with this ID already exists.\n";
                    break;
                }
                bus.serviceName = InputHelper::readNonEmptyString("Service name: ", 40);
                bus.origin = InputHelper::readNonEmptyString("Origin city: ", 30);
                bus.destination = InputHelper::readNonEmptyString("Destination city: ", 30);
                bus.departureTime = InputHelper::readTimeString("Departure time (HH:MM): ");
                bus.arrivalTime = InputHelper::readTimeString("Arrival time (HH:MM): ");
                bus.totalSeats = InputHelper::readInt("Total seats (20-80): ", 20, 80);
                bus.availableSeats = bus.totalSeats;
                bus.fareEuro = InputHelper::readDouble("Fare per seat (€15-€150): ", 15.0, 150.0);
                bus.active = true;
                store.getBuses().push_back(bus);
                std::cout << "✅  Bus service created successfully.\n";
                break;
            }
            case 3:
            {
                View::listBuses(store.getBuses());
                const int busId = InputHelper::readInt("Bus ID to update: ", 1, 9999);
                Bus *bus = store.findBus(busId);
                if (bus == nullptr)
                {
                    std::cout << "❌  Bus not found.\n";
                    break;
                }
                std::cout << "Updating service: " << bus->serviceName << "\n";
                std::cout << "1. Update fare\n2. Update seat capacity\n3. Toggle availability\n";
                const int updateOption = InputHelper::readInt("Select update option: ", 1, 3);
                if (updateOption == 1)
                {
                    double newFare = InputHelper::readDouble("New fare (€15-€200): ", 15.0, 200.0);
                    bus->fareEuro = newFare;
                    std::cout << "✅  Fare updated.\n";
                }
                else if (updateOption == 2)
                {
                    int newCapacity = InputHelper::readInt("New total seats (20-90): ", 20, 90);
                    int soldSeats = bus->totalSeats - bus->availableSeats;
                    if (newCapacity < soldSeats)
                    {
                        std::cout << "❌  Cannot reduce capacity below sold seats (" << soldSeats << ").\n";
                    }
                    else
                    {
                        bus->totalSeats = newCapacity;
                        bus->availableSeats = newCapacity - soldSeats;
                        std::cout << "✅  Capacity updated.\n";
                    }
                }
                else if (updateOption == 3)
                {
                    bus->active = !bus->active;
                    std::cout << "✅  Service availability set to " << (bus->active ? "Active" : "Inactive") << ".\n";
                }
                break;
            }
            case 4:
                reportService.showOccupancyReport();
                break;
            case 5:
                reportService.showBookingAudit();
                break;
            case 6:
            {
                const std::string username = InputHelper::readNonEmptyString("Username to reset password for: ", 32);
                const std::string newPassword = InputHelper::readNonEmptyString("New temporary password: ", 32);
                if (securityService.resetPassword(username, newPassword))
                {
                    std::cout << "✅  Password reset successfully.\n";
                }
                else
                {
                    std::cout << "❌  Failed to reset password. User may not exist.\n";
                }
                break;
            }
            case 7:
                keepRunning = false;
                std::cout << "Logging out...\n";
                break;
            default:
                break;
            }
        }
    }

    std::optional<User> loginWorkflow(SecurityService &securityService)
    {
        for (int attempt = 1; attempt <= kMaxLoginAttempts; ++attempt)
        {
            const std::string username = InputHelper::readNonEmptyString("Username: ", 32);
            const std::string password = InputHelper::readNonEmptyString("Password: ", 64);

            auto user = securityService.authenticate(username, password);
            if (user)
            {
                std::cout << "✅  Login successful. Welcome, " << user->username << " (" << roleToString(user->role)
                          << ")\n";
                return user;
            }

            std::cout << "❌  Invalid credentials. Attempts remaining: " << (kMaxLoginAttempts - attempt) << "\n";
        }

        std::cout << "Account locked for this session due to multiple failed attempts.\n";
        return std::nullopt;
    }

    void registerCustomerWorkflow(SecurityService &securityService)
    {
        std::cout << "\n=== Customer Registration ===\n";
        const std::string username = InputHelper::readNonEmptyString("Choose a username: ", 32);
        const std::string password = InputHelper::readNonEmptyString("Choose a strong password: ", 64);
        if (securityService.registerCustomer(username, password))
        {
            std::cout << "✅  Account created successfully. You can now log in.\n";
        }
        else
        {
            std::cout << "❌  Username already exists. Please try a different one.\n";
        }
    }

} // namespace

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    DataStore store;
    SecurityService securityService(store);
    BookingService bookingService(store);

    bool running = true;
    while (running)
    {
        View::printBanner();
        View::showMainMenu();
        const int choice = InputHelper::readInt("Select an option: ", 1, 4);

        switch (choice)
        {
        case 1:
        {
            auto loggedIn = loginWorkflow(securityService);
            if (!loggedIn)
            {
                break;
            }

            User *user = store.findUserMutable(loggedIn->username);
            if (user == nullptr)
            {
                std::cout << "❌  Unexpected error: user not found after login.\n";
                break;
            }

            if (user->role == Role::Customer)
            {
                customerWorkflow(*user, store, bookingService);
            }
            else if (user->role == Role::Agent)
            {
                agentWorkflow(*user, store, bookingService);
            }
            else if (user->role == Role::Admin)
            {
                adminWorkflow(*user, store, bookingService, securityService);
            }
            break;
        }
        case 2:
            registerCustomerWorkflow(securityService);
            break;
        case 3:
            View::showHelp();
            break;
        case 4:
            running = false;
            std::cout << "Exiting EuroBus Portal. Safe travels!\n";
            break;
        default:
            break;
        }
    }

    return 0;
}
